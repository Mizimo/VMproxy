#!/bin/bash
# vmproxy - cross-platform proxy manager for VMs
# 讓虛擬機一鍵切換 HTTP/HTTPS/SOCKS 代理，支援 macOS 與 Linux
# Author: 藥アイ & ChatGPT & Claude

VERSION="2026.02.17.3"
UPDATE_URL="https://raw.githubusercontent.com/Mizimo/VMproxy/master/vmproxy"

# ========================================
# A. 全域變數 + OS 偵測
# ========================================

OS="$(uname -s)"   # "Darwin" or "Linux"

CONFIG_FILE="$HOME/.vmproxy.conf"
PROFILE_FILE="$HOME/.vmproxy_env"
SCRIPT_NAME="vmproxy"

GREEN='\033[0;32m'; YELLOW='\033[1;33m'; RED='\033[1;31m'; CYAN='\033[0;36m'; NC='\033[0m'

# ========================================
# B. 共用函數
# ========================================

# --- 載入/初始化設定 ---
function load_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        source "$CONFIG_FILE"
    fi
    PROXY_HOST="${PROXY_HOST:-192.168.1.1}"
    MIXED_PORT="${MIXED_PORT:-7890}"
    HTTP_PORT="${HTTP_PORT:-$MIXED_PORT}"
    SOCKS_PORT="${SOCKS_PORT:-$MIXED_PORT}"
}

function save_config() {
    cat > "$CONFIG_FILE" <<EOF
# vmproxy config — 由 vmproxy 自動產生，可安全刪除
PROXY_HOST="$PROXY_HOST"
MIXED_PORT="$MIXED_PORT"

# 若 HTTP 與 SOCKS 需要不同端口，取消註解並修改：
# HTTP_PORT="$MIXED_PORT"
# SOCKS_PORT="$MIXED_PORT"
EOF
}

# --- sed -i 跨平台 wrapper ---
function sed_i() {
    if [[ "$OS" == "Darwin" ]]; then
        sed -i '' "$@"
    else
        sed -i "$@"
    fi
}

# --- 網路工具 ---

# TCP 端口連通性測試
# macOS nc: -G = 連線超時（-w 只是閒置超時，不限制 SYN）
# Linux nc: -w = 連線超時
function test_host_reachable() {
    local host="$1" port="$2"
    if command -v nc &>/dev/null; then
        if [[ "$OS" == "Darwin" ]]; then
            nc -z -G 1 "$host" "$port" 2>/dev/null
        else
            nc -z -w 1 "$host" "$port" 2>/dev/null
        fi
    elif command -v ncat &>/dev/null; then
        ncat -z -w 1 "$host" "$port" 2>/dev/null
    else
        (echo >/dev/tcp/"$host"/"$port") 2>/dev/null
    fi
}

# 取得本機 IP
function get_local_ip() {
    case "$OS" in
        Darwin)
            local iface
            iface=$(route -n get default 2>/dev/null | awk '/interface:/{print $2}')
            [[ -n "$iface" ]] && ipconfig getifaddr "$iface" 2>/dev/null
            ;;
        Linux)
            ip -4 route get 1.1.1.1 2>/dev/null | awk '/src/{for(i=1;i<=NF;i++) if($i=="src") print $(i+1)}'
            ;;
    esac
}

# 掃描結果選擇（1 台直接回傳，多台讓用戶選）
# 用法: select_and_return port ip1 ip2 ...
function select_and_return() {
    local port="$1"
    shift
    local ips=("$@")

    if [[ ${#ips[@]} -eq 1 ]]; then
        echo -e "  ${GREEN}[找到] ${ips[0]}:${port}${NC}" >&2
        echo "${ips[0]}"
        return 0
    fi

    echo -e "  ${GREEN}[找到 ${#ips[@]} 台代理伺服器]${NC}" >&2
    local i=1
    for ip in "${ips[@]}"; do
        echo "  ${i}) ${ip}:${port}" >&2
        ((i++))
    done
    echo "" >&2
    read -rp "  選擇 [1-${#ips[@]}]: " choice
    if [[ "$choice" =~ ^[0-9]+$ ]] && (( choice >= 1 && choice <= ${#ips[@]} )); then
        echo -e "  ${GREEN}[選擇] ${ips[$((choice-1))]}${NC}" >&2
        echo "${ips[$((choice-1))]}"
        return 0
    else
        echo -e "  ${RED}[錯誤] 無效的選擇${NC}" >&2
        return 1
    fi
}

# 掃描區域網路尋找代理伺服器
# 用法: scan_proxy_server [port] [range]
# 成功時輸出找到的 IP (stdout)，狀態訊息輸出到 stderr
function scan_proxy_server() {
    local port="${1:-$MIXED_PORT}"
    local range="${2:-}"

    echo -e "${CYAN}→ 掃描區域網路中的代理伺服器 (port ${port})...${NC}" >&2

    local my_ip
    my_ip=$(get_local_ip)

    local tmpdir
    tmpdir=$(mktemp -d) || return 1
    trap "rm -rf '$tmpdir'" RETURN

    # ---- Phase 1: ARP 快掃 ----
    local arp_hosts=()
    while IFS= read -r ip; do
        [[ -z "$ip" || "$ip" == "$my_ip" ]] && continue
        arp_hosts+=("$ip")
    done < <(arp -a 2>/dev/null | grep -oE '\([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+\)' | tr -d '()')

    if [[ ${#arp_hosts[@]} -gt 0 ]]; then
        local arp_count=${#arp_hosts[@]}

        if [[ $arp_count -gt 10 ]]; then
            echo "" >&2
            echo -e "  ${RED}[警告] ARP 表中有 ${arp_count} 台設備${NC}" >&2
            echo "" >&2
            echo -e "  ${RED}大量端口掃描${NC}在${RED}公司或公共網路${NC}中可能觸發安全警報，" >&2
            echo -e "  或被網管視為${RED}攻擊行為${NC}。建議使用 --range 縮小範圍。" >&2
            echo "" >&2
            echo -e "  繼續操作即表示${RED}你已獲得該網路的使用授權，後果自負${NC}。" >&2
            echo "" >&2
            read -rp "  繼續掃描？（僅測試 ARP 已知設備，不掃描全子網）[y/N]: " choice
            if [[ "$choice" != [yY] ]]; then
                echo "" >&2
                echo -e "  提示: ${CYAN}$SCRIPT_NAME config <IP> <port>${NC}" >&2
                echo -e "        ${CYAN}$SCRIPT_NAME config auto --range 192.168.1.1-50${NC}" >&2
                return 2  # 用戶取消，區別於 1（未找到）
            fi
        fi

        echo -e "  ARP 快掃 (${arp_count} 台)..." >&2
        local idx=0
        for h in "${arp_hosts[@]}"; do
            (test_host_reachable "$h" "$port" && echo "$h" > "$tmpdir/arp_$idx") &
            ((idx++))
        done
        wait

        local found_ips=()
        for ((i=0; i<idx; i++)); do
            if [[ -f "$tmpdir/arp_$i" ]]; then
                found_ips+=("$(cat "$tmpdir/arp_$i")")
            fi
        done

        if [[ ${#found_ips[@]} -gt 0 ]]; then
            select_and_return "$port" "${found_ips[@]}"
            return $?
        fi
    fi

    # ---- Phase 2: 子網全掃 ----
    if [[ -z "$my_ip" ]]; then
        echo -e "${RED}[錯誤] 無法取得本機 IP${NC}" >&2
        return 1
    fi

    local prefix="${my_ip%.*}"
    local start_octet=1
    local end_octet=254

    if [[ -n "$range" ]]; then
        # 支援 "192.168.1.1-50" 或 "1-50" 格式
        if [[ "$range" == *"."* ]]; then
            prefix="${range%.*}"
            local last_part="${range##*.}"
            start_octet="${last_part%%-*}"
            end_octet="${last_part##*-}"
        else
            start_octet="${range%%-*}"
            end_octet="${range##*-}"
        fi
    fi

    local total=$((end_octet - start_octet + 1))
    echo -e "  子網掃描 ${prefix}.${start_octet}-${end_octet} (${total} 台)..." >&2

    for i in $(seq "$start_octet" "$end_octet"); do
        local target="${prefix}.${i}"
        [[ "$target" == "$my_ip" ]] && continue
        (test_host_reachable "$target" "$port" && echo "$target" > "$tmpdir/sub_${i}") &
    done
    wait

    local found_ips=()
    for i in $(seq "$start_octet" "$end_octet"); do
        if [[ -f "$tmpdir/sub_${i}" ]]; then
            found_ips+=("$(cat "$tmpdir/sub_${i}")")
        fi
    done

    if [[ ${#found_ips[@]} -gt 0 ]]; then
        select_and_return "$port" "${found_ips[@]}"
        return $?
    fi

    echo -e "  ${RED}未找到開放 port ${port} 的設備${NC}" >&2
    return 1
}

# --- 設定代理位址 ---
function config_proxy() {
    load_config
    if [[ -z "${2:-}" ]]; then
        echo "---- $SCRIPT_NAME 當前設定 ----"
        echo -e "  位址: ${CYAN}${PROXY_HOST}${NC}"
        echo -e "  端口: ${CYAN}${MIXED_PORT}${NC}"
        if [[ "$HTTP_PORT" != "$MIXED_PORT" ]]; then
            echo -e "  HTTP 端口: ${CYAN}${HTTP_PORT}${NC}"
        fi
        if [[ "$SOCKS_PORT" != "$MIXED_PORT" ]]; then
            echo -e "  SOCKS 端口: ${CYAN}${SOCKS_PORT}${NC}"
        fi
        echo ""
        echo "用法:"
        echo "  $SCRIPT_NAME config <host> [port]        設定代理位址與連接埠"
        echo "  $SCRIPT_NAME config <host>:<port>        設定代理位址與連接埠"
        echo "  $SCRIPT_NAME config <port>               只設定端口"
        echo "  $SCRIPT_NAME config auto [port]          自動掃描區域網偵測代理伺服器"
        echo "  $SCRIPT_NAME config auto --range <range> 限定掃描範圍"
        echo ""
        echo "範例:"
        echo "  $SCRIPT_NAME config 192.168.1.100 7890"
        echo "  $SCRIPT_NAME config 192.168.1.100:1080"
        echo "  $SCRIPT_NAME config 7890"
        echo "  $SCRIPT_NAME config auto"
        echo "  $SCRIPT_NAME config auto 7891"
        echo "  $SCRIPT_NAME config auto --range 192.168.1.1-50"
        return
    fi

    local input="$2"

    # ---- auto 模式：掃描 LAN ----
    if [[ "$input" == "auto" ]]; then
        local scan_port="$MIXED_PORT"
        local range=""
        shift 2
        while [[ $# -gt 0 ]]; do
            case "$1" in
                --range)
                    range="${2:-}"
                    shift 2
                    ;;
                *)
                    scan_port="$1"
                    shift
                    ;;
            esac
        done

        local found_ip
        found_ip=$(scan_proxy_server "$scan_port" "$range")
        local scan_ret=$?
        if [[ $scan_ret -eq 0 && -n "$found_ip" ]]; then
            PROXY_HOST="$found_ip"
            MIXED_PORT="$scan_port"
            HTTP_PORT="$scan_port"
            SOCKS_PORT="$scan_port"
            save_config
            echo -e "${GREEN}[OK] 設定已儲存${NC}"
            echo -e "  位址: ${CYAN}${PROXY_HOST}${NC}"
            echo -e "  端口: ${CYAN}${MIXED_PORT}${NC}"
            echo -e "  提示: 執行 ${CYAN}$SCRIPT_NAME on${NC} 使新設定生效"
        elif [[ $scan_ret -eq 2 ]]; then
            # 用戶取消，scan 已印提示，不重複輸出
            :
        else
            echo -e "${RED}[錯誤] 未找到可用的代理伺服器${NC}"
            echo -e "  提示: 確認代理軟體是否啟動並開啟區域網路連線"
            echo -e "        ${CYAN}$SCRIPT_NAME config <IP> <port>${NC} 手動設定"
        fi
        return
    fi

    # ---- 一般模式 ----
    local new_port="${3:-}"

    if [[ "$input" =~ ^[0-9]+$ ]]; then
        # 純數字 → 只改端口
        MIXED_PORT="$input"
        HTTP_PORT="$input"
        SOCKS_PORT="$input"
    elif [[ "$input" == *":"* && -z "$new_port" ]]; then
        # host:port 格式
        PROXY_HOST="${input%%:*}"
        MIXED_PORT="${input##*:}"
        HTTP_PORT="$MIXED_PORT"
        SOCKS_PORT="$MIXED_PORT"
    elif [[ "$input" == *"."* ]]; then
        # 含 . → IP 位址（可選端口）
        PROXY_HOST="$input"
        if [[ -n "$new_port" ]]; then
            MIXED_PORT="$new_port"
            HTTP_PORT="$new_port"
            SOCKS_PORT="$new_port"
        fi
    else
        # 其他 → 當作 host
        PROXY_HOST="$input"
        if [[ -n "$new_port" ]]; then
            MIXED_PORT="$new_port"
            HTTP_PORT="$new_port"
            SOCKS_PORT="$new_port"
        fi
    fi

    save_config
    echo -e "${GREEN}[OK] 設定已儲存${NC}"
    echo -e "  位址: ${CYAN}${PROXY_HOST}${NC}"
    echo -e "  端口: ${CYAN}${MIXED_PORT}${NC}"
    echo -e "  提示: 執行 ${CYAN}$SCRIPT_NAME on${NC} 使新設定生效"
}

# --- Shell 設定檔偵測 ---
function detect_rc_file() {
    case "$(basename "$SHELL")" in
        zsh)  echo "$HOME/.zshrc" ;;
        bash) echo "$HOME/.bashrc" ;;
        fish) echo "$HOME/.config/fish/config.fish" ;;
        *)    echo "$HOME/.profile" ;;
    esac
}

# 取得所有需要寫入的設定檔
# .bashrc 僅供互動式 shell 讀取；非互動 SSH 命令 (ssh host 'cmd')
# 不會讀 .bashrc，因此需要同時寫入 .profile/.bash_profile
function get_init_files() {
    local files=()
    local rc_file
    rc_file=$(detect_rc_file)
    files+=("$rc_file")

    local shell_name
    shell_name=$(basename "$SHELL")

    if [[ "$shell_name" == "bash" ]]; then
        # bash 登入 shell 讀取順序: .bash_profile > .bash_login > .profile (只讀第一個存在的)
        # 非互動 SSH 命令也走登入 shell 路徑
        if [[ -f "$HOME/.bash_profile" ]]; then
            files+=("$HOME/.bash_profile")
        elif [[ -f "$HOME/.bash_login" ]]; then
            files+=("$HOME/.bash_login")
        else
            files+=("$HOME/.profile")
        fi
    elif [[ "$shell_name" == "zsh" ]]; then
        # zsh 登入時讀 .zprofile，互動時讀 .zshrc，兩者都要寫
        files+=("$HOME/.zprofile")
    fi

    # 去重
    printf '%s\n' "${files[@]}" | sort -u
}

SHELL_HOOK='# >>> vmproxy >>>
[[ -f ~/.vmproxy_env ]] && source ~/.vmproxy_env
function vmproxy() {
    command vmproxy "$@"
    case "$1" in
        on)  [[ -f ~/.vmproxy_env ]] && source ~/.vmproxy_env ;;
        off) unset http_proxy https_proxy all_proxy HTTP_PROXY HTTPS_PROXY ALL_PROXY ;;
        doctor)
            [[ "${2:-}" == "cleanup" ]] && unset http_proxy https_proxy all_proxy HTTP_PROXY HTTPS_PROXY ALL_PROXY
            ;;
    esac
}
# <<< vmproxy <<<'

# ========================================
# C. macOS 專用函數
# ========================================

# --- 自動偵測活躍網路介面 (macOS) ---
function detect_services() {
    local services=()
    while IFS= read -r svc; do
        [[ "$svc" == *"*"* ]] && continue  # 跳過已停用的介面
        [[ -z "$svc" ]] && continue
        local ip
        ip=$(networksetup -getinfo "$svc" 2>/dev/null | grep "^IP address:" | awk '{print $3}')
        if [[ -n "$ip" && "$ip" != "none" ]]; then
            services+=("$svc")
        fi
    done < <(networksetup -listallnetworkservices 2>/dev/null | tail -n +2)

    if [[ ${#services[@]} -eq 0 ]]; then
        echo -e "${RED}[錯誤] 未找到活躍的網路介面${NC}" >&2
        return 1
    fi
    printf '%s\n' "${services[@]}"
}

function mac_enable_proxy() {
    local services
    services=$(detect_services) || return 1

    while IFS= read -r svc; do
        echo -e "  ${CYAN}[$svc]${NC}"
        networksetup -setwebproxy "$svc" "$PROXY_HOST" "$HTTP_PORT"
        networksetup -setsecurewebproxy "$svc" "$PROXY_HOST" "$HTTP_PORT"
        networksetup -setsocksfirewallproxy "$svc" "$PROXY_HOST" "$SOCKS_PORT"
        networksetup -setwebproxystate "$svc" on
        networksetup -setsecurewebproxystate "$svc" on
        networksetup -setsocksfirewallproxystate "$svc" on
    done <<< "$services"
}

function mac_disable_proxy() {
    local services
    services=$(detect_services) || return 1

    while IFS= read -r svc; do
        echo -e "  ${CYAN}[$svc]${NC}"
        networksetup -setwebproxystate "$svc" off
        networksetup -setsecurewebproxystate "$svc" off
        networksetup -setsocksfirewallproxystate "$svc" off
    done <<< "$services"
}

function mac_show_status() {
    local services
    services=$(detect_services) || return 1

    while IFS= read -r svc; do
        echo -e "  ${CYAN}[$svc]${NC}"
        local http_state https_state socks_state
        http_state=$(networksetup -getwebproxy "$svc" 2>/dev/null | grep "^Enabled:" | awk '{print $2}')
        https_state=$(networksetup -getsecurewebproxy "$svc" 2>/dev/null | grep "^Enabled:" | awk '{print $2}')
        socks_state=$(networksetup -getsocksfirewallproxy "$svc" 2>/dev/null | grep "^Enabled:" | awk '{print $2}')
        printf "    HTTP: %-5s  HTTPS: %-5s  SOCKS: %-5s\n" "$http_state" "$https_state" "$socks_state"
    done <<< "$services"
}

# ========================================
# D. Linux 專用函數
# ========================================

# --- 偵測桌面環境 ---
function detect_de() {
    if [[ -n "${XDG_CURRENT_DESKTOP:-}" ]]; then
        local xdg_lower
        xdg_lower=$(printf '%s' "$XDG_CURRENT_DESKTOP" | tr '[:upper:]' '[:lower:]')
        case "$xdg_lower" in
            *gnome*|*unity*|*budgie*|*cinnamon*|*pantheon*)
                echo "gnome" ;;
            *kde*)
                echo "kde" ;;
            *)
                echo "unknown" ;;
        esac
    elif [[ -n "${GNOME_DESKTOP_SESSION_ID:-}" ]]; then
        echo "gnome"
    elif [[ -n "${KDE_FULL_SESSION:-}" ]]; then
        echo "kde"
    else
        echo "unknown"
    fi
}

# --- 偵測活躍網路介面 (Linux) ---
function detect_interfaces() {
    local interfaces=()
    while IFS= read -r iface; do
        [[ -z "$iface" ]] && continue
        [[ "$iface" == "lo" ]] && continue
        local state
        state=$(ip link show "$iface" 2>/dev/null | grep -o 'state [A-Z]*' | awk '{print $2}')
        if [[ "$state" == "UP" ]]; then
            local ip_addr
            ip_addr=$(ip -4 addr show "$iface" 2>/dev/null | grep -oE 'inet [0-9.]+' | awk '{print $2}')
            if [[ -n "$ip_addr" ]]; then
                interfaces+=("$iface ($ip_addr)")
            fi
        fi
    done < <(ip -o link show 2>/dev/null | awk -F': ' '{print $2}' | sed 's/@.*//')

    if [[ ${#interfaces[@]} -eq 0 ]]; then
        echo -e "${RED}[錯誤] 未找到活躍的網路介面${NC}" >&2
        return 1
    fi
    printf '%s\n' "${interfaces[@]}"
}

# --- GNOME 代理設定 ---
function gnome_proxy_on() {
    gsettings set org.gnome.system.proxy mode 'manual'
    gsettings set org.gnome.system.proxy.http host "$PROXY_HOST"
    gsettings set org.gnome.system.proxy.http port "$HTTP_PORT"
    gsettings set org.gnome.system.proxy.https host "$PROXY_HOST"
    gsettings set org.gnome.system.proxy.https port "$HTTP_PORT"
    gsettings set org.gnome.system.proxy.socks host "$PROXY_HOST"
    gsettings set org.gnome.system.proxy.socks port "$SOCKS_PORT"
}

function gnome_proxy_off() {
    gsettings set org.gnome.system.proxy mode 'none'
}

function gnome_proxy_status() {
    local mode http_host http_port https_host https_port socks_host socks_port
    mode=$(gsettings get org.gnome.system.proxy mode 2>/dev/null | tr -d "'")
    http_host=$(gsettings get org.gnome.system.proxy.http host 2>/dev/null | tr -d "'")
    http_port=$(gsettings get org.gnome.system.proxy.http port 2>/dev/null)
    https_host=$(gsettings get org.gnome.system.proxy.https host 2>/dev/null | tr -d "'")
    https_port=$(gsettings get org.gnome.system.proxy.https port 2>/dev/null)
    socks_host=$(gsettings get org.gnome.system.proxy.socks host 2>/dev/null | tr -d "'")
    socks_port=$(gsettings get org.gnome.system.proxy.socks port 2>/dev/null)

    echo -e "  代理模式: ${CYAN}${mode}${NC}"
    echo "    HTTP:  ${http_host}:${http_port}"
    echo "    HTTPS: ${https_host}:${https_port}"
    echo "    SOCKS: ${socks_host}:${socks_port}"
}

# --- KDE 代理設定 ---
function kde_find_kwriteconfig() {
    if command -v kwriteconfig6 &>/dev/null; then
        echo "kwriteconfig6"
    elif command -v kwriteconfig5 &>/dev/null; then
        echo "kwriteconfig5"
    else
        echo ""
    fi
}

function kde_find_kreadconfig() {
    if command -v kreadconfig6 &>/dev/null; then
        echo "kreadconfig6"
    elif command -v kreadconfig5 &>/dev/null; then
        echo "kreadconfig5"
    else
        echo ""
    fi
}

function kde_proxy_on() {
    local kw
    kw=$(kde_find_kwriteconfig)
    if [[ -z "$kw" ]]; then
        echo -e "${RED}[錯誤] 未找到 kwriteconfig5/6${NC}" >&2
        return 1
    fi
    # KDE ProxyType: 0=直接, 1=手動, 2=PAC, 3=自動偵測, 4=系統
    "$kw" --file kioslaverc --group "Proxy Settings" --key ProxyType 1
    "$kw" --file kioslaverc --group "Proxy Settings" --key httpProxy "http://${PROXY_HOST} ${HTTP_PORT}"
    "$kw" --file kioslaverc --group "Proxy Settings" --key httpsProxy "http://${PROXY_HOST} ${HTTP_PORT}"
    "$kw" --file kioslaverc --group "Proxy Settings" --key socksProxy "socks://${PROXY_HOST} ${SOCKS_PORT}"
    # 通知 KDE 重新載入設定
    if command -v dbus-send &>/dev/null; then
        dbus-send --type=signal /KIO/Scheduler org.kde.KIO.Scheduler.reparseSlaveConfiguration string:""
    fi
}

function kde_proxy_off() {
    local kw
    kw=$(kde_find_kwriteconfig)
    if [[ -z "$kw" ]]; then
        echo -e "${RED}[錯誤] 未找到 kwriteconfig5/6${NC}" >&2
        return 1
    fi
    "$kw" --file kioslaverc --group "Proxy Settings" --key ProxyType 0
    if command -v dbus-send &>/dev/null; then
        dbus-send --type=signal /KIO/Scheduler org.kde.KIO.Scheduler.reparseSlaveConfiguration string:""
    fi
}

function kde_proxy_status() {
    local kr
    kr=$(kde_find_kreadconfig)
    if [[ -z "$kr" ]]; then
        echo -e "  ${RED}未找到 kreadconfig5/6${NC}"
        return
    fi
    local proxy_type http_proxy https_proxy socks_proxy
    proxy_type=$("$kr" --file kioslaverc --group "Proxy Settings" --key ProxyType 2>/dev/null)
    http_proxy=$("$kr" --file kioslaverc --group "Proxy Settings" --key httpProxy 2>/dev/null)
    https_proxy=$("$kr" --file kioslaverc --group "Proxy Settings" --key httpsProxy 2>/dev/null)
    socks_proxy=$("$kr" --file kioslaverc --group "Proxy Settings" --key socksProxy 2>/dev/null)

    local mode_text="直接連線"
    case "$proxy_type" in
        1) mode_text="手動" ;;
        2) mode_text="PAC" ;;
        3) mode_text="自動偵測" ;;
        4) mode_text="系統" ;;
    esac
    echo -e "  代理模式: ${CYAN}${mode_text}${NC} (type=${proxy_type})"
    echo "    HTTP:  ${http_proxy:-未設定}"
    echo "    HTTPS: ${https_proxy:-未設定}"
    echo "    SOCKS: ${socks_proxy:-未設定}"
}

function linux_enable_proxy() {
    local de
    de=$(detect_de)

    # 顯示活躍介面（僅供參考）
    local interfaces
    interfaces=$(detect_interfaces 2>/dev/null)
    if [[ -n "$interfaces" ]]; then
        echo -e "  活躍介面:"
        while IFS= read -r iface; do
            echo -e "    ${CYAN}${iface}${NC}"
        done <<< "$interfaces"
    fi

    # 設定桌面環境代理
    case "$de" in
        gnome)
            echo -e "  桌面環境: ${CYAN}GNOME${NC}"
            gnome_proxy_on
            ;;
        kde)
            echo -e "  桌面環境: ${CYAN}KDE${NC}"
            kde_proxy_on
            ;;
        *)
            echo -e "  桌面環境: ${YELLOW}未知 (僅設定環境變數)${NC}"
            ;;
    esac
}

function linux_disable_proxy() {
    local de
    de=$(detect_de)

    case "$de" in
        gnome)
            echo -e "  桌面環境: ${CYAN}GNOME${NC}"
            gnome_proxy_off
            ;;
        kde)
            echo -e "  桌面環境: ${CYAN}KDE${NC}"
            kde_proxy_off
            ;;
        *)
            echo -e "  桌面環境: ${YELLOW}未知 (僅清除環境變數)${NC}"
            ;;
    esac
}

function linux_show_status() {
    local de
    de=$(detect_de)

    # 顯示活躍介面
    local interfaces
    interfaces=$(detect_interfaces 2>/dev/null)
    if [[ -n "$interfaces" ]]; then
        echo "  活躍介面:"
        while IFS= read -r iface; do
            echo -e "    ${CYAN}${iface}${NC}"
        done <<< "$interfaces"
        echo ""
    fi

    # 顯示桌面環境代理狀態
    echo -e "  桌面環境: ${CYAN}${de}${NC}"
    case "$de" in
        gnome) gnome_proxy_status ;;
        kde)   kde_proxy_status ;;
        *)     echo -e "  ${YELLOW}無法讀取桌面環境代理設定${NC}" ;;
    esac
}

# ========================================
# E. 調度函數
# ========================================

function enable_proxy() {
    load_config

    # 測試已設定的代理伺服器連通性
    if ! test_host_reachable "$PROXY_HOST" "$MIXED_PORT"; then
        echo -e "${YELLOW}[警告] ${PROXY_HOST}:${MIXED_PORT} 無法連線，掃描區域網路...${NC}"
        local found_ip
        found_ip=$(scan_proxy_server "$MIXED_PORT")
        local scan_ret=$?
        if [[ $scan_ret -eq 0 && -n "$found_ip" ]]; then
            PROXY_HOST="$found_ip"
            echo -e "  提示: 執行 ${CYAN}$SCRIPT_NAME config ${found_ip}${NC} 儲存設定"
        elif [[ $scan_ret -ne 2 ]]; then
            echo -e "${RED}[錯誤] 找不到可用的代理伺服器${NC}"
            echo -e "  提示: 確認代理軟體是否啟動並開啟區域網路連線"
            echo -e "        ${CYAN}$SCRIPT_NAME config <IP> <port>${NC} 手動設定"
            return 1
        else
            return 1
        fi
    fi

    echo -e "${GREEN}→ 啟用系統代理: http://${PROXY_HOST}:${HTTP_PORT}${NC}"

    case "$OS" in
        Darwin) mac_enable_proxy ;;
        Linux)  linux_enable_proxy ;;
        *)      echo -e "${YELLOW}未知作業系統，僅設定環境變數${NC}" ;;
    esac

    # 寫入環境變數檔（大小寫都寫，相容所有工具）
    cat > "$PROFILE_FILE" <<EOF
# vmproxy env — 由 vmproxy on 產生，vmproxy off 時刪除，可安全刪除
export http_proxy=http://${PROXY_HOST}:${HTTP_PORT}
export https_proxy=http://${PROXY_HOST}:${HTTP_PORT}
export all_proxy=socks5://${PROXY_HOST}:${SOCKS_PORT}
export HTTP_PROXY=http://${PROXY_HOST}:${HTTP_PORT}
export HTTPS_PROXY=http://${PROXY_HOST}:${HTTP_PORT}
export ALL_PROXY=socks5://${PROXY_HOST}:${SOCKS_PORT}
EOF

    echo -e "${GREEN}[OK] 系統代理已啟用${NC}"
    echo -e "  \033[1;36m提示: 執行 source ~/.vmproxy_env 使當前終端生效${NC}"
}

function disable_proxy() {
    echo -e "${YELLOW}→ 關閉系統代理${NC}"

    case "$OS" in
        Darwin) mac_disable_proxy ;;
        Linux)  linux_disable_proxy ;;
        *)      echo -e "${YELLOW}未知作業系統，僅清除環境變數${NC}" ;;
    esac

    rm -f "$PROFILE_FILE"
    echo -e "${YELLOW}[OK] 系統代理已關閉${NC}"
    echo -e "  \033[1;36m提示: 執行 unset http_proxy https_proxy all_proxy HTTP_PROXY HTTPS_PROXY ALL_PROXY 清除當前終端變數${NC}"
}

function show_status() {
    load_config
    echo "---- $SCRIPT_NAME 狀態 ----"
    echo -e "設定: ${CYAN}${PROXY_HOST}:${MIXED_PORT}${NC}"
    echo -e "系統: ${CYAN}${OS}${NC}"

    # 即時連通性檢查
    if test_host_reachable "$PROXY_HOST" "$MIXED_PORT"; then
        echo -e "連線: ${GREEN}✓ 可達${NC}"
    else
        echo -e "連線: ${RED}✗ 不可達${NC} (${CYAN}$SCRIPT_NAME config auto${NC} 重新偵測)"
    fi
    echo ""

    case "$OS" in
        Darwin) mac_show_status ;;
        Linux)  linux_show_status ;;
        *)      echo -e "  ${YELLOW}未知作業系統${NC}" ;;
    esac

    echo ""
    if [[ -n "${http_proxy:-}" ]]; then
        echo -e "  [ENV] http_proxy=${http_proxy}"
        echo -e "  [ENV] https_proxy=${https_proxy:-未設定}"
        echo -e "  [ENV] all_proxy=${all_proxy:-未設定}"
    else
        echo -e "  [ENV] ${RED}環境變數未設定${NC}"
    fi
    echo "------------------------"
}

function init_shell() {
    local files=()
    while IFS= read -r f; do files+=("$f"); done < <(get_init_files)
    local wrote=0

    # 將 wrapper 中的 vmproxy 替換為完整路徑，不依賴 PATH
    local self
    self=$(resolve_self_path)
    local hook="${SHELL_HOOK/command vmproxy/command \"$self\"}"

    for f in "${files[@]}"; do
        if grep -qF '>>> vmproxy >>>' "$f" 2>/dev/null; then
            echo -e "${YELLOW}[略過] ${f} 中已存在 $SCRIPT_NAME 設定${NC}"
            continue
        fi
        # 移除舊版 hook（無 marker）
        if grep -qF 'vmproxy_env' "$f" 2>/dev/null; then
            sed_i '/# vmproxy.*載入/d;/vmproxy_env/d' "$f"
            sed_i -e :a -e '/^\n*$/{$d;N;ba' -e '}' "$f"
            echo -e "${YELLOW}[升級] 移除 ${f} 中的舊版設定${NC}"
        fi
        echo "" >> "$f"
        echo "$hook" >> "$f"
        echo -e "${GREEN}[OK] 已寫入 ${f}${NC}"
        wrote=1
    done

    if [[ $wrote -eq 1 ]]; then
        echo -e "  互動式終端與 SSH 非互動命令都會自動載入代理環境變數"
        echo -e "  ${CYAN}vmproxy on/off${NC} 會自動更新當前終端環境變數"
    fi

    # 提示 ~/.ssh/environment 方案（需 sshd 設定 PermitUserEnvironment）
    echo ""
    echo -e "  ${CYAN}[提示]${NC} 若 SSH 非互動命令仍未生效，可另外設定:"
    echo -e "    1. 將代理變數寫入 ${CYAN}~/.ssh/environment${NC}"
    echo -e "    2. 確認 sshd_config 中 ${CYAN}PermitUserEnvironment yes${NC}"
}

function uninit_shell() {
    local files=()
    while IFS= read -r f; do files+=("$f"); done < <(get_init_files)

    for f in "${files[@]}"; do
        local found=0
        # 新版 marker 格式（驗證配對完整才刪除，避免缺少結束 marker 時誤刪到 EOF）
        local has_open has_close
        has_open=$(grep -c '^# >>> vmproxy >>>$' "$f" 2>/dev/null)
        has_close=$(grep -c '^# <<< vmproxy <<<$' "$f" 2>/dev/null)
        if [[ $has_open -gt 0 && $has_close -gt 0 ]]; then
            sed_i '/^# >>> vmproxy >>>$/,/^# <<< vmproxy <<<$/d' "$f"
            found=1
        elif [[ $has_open -gt 0 || $has_close -gt 0 ]]; then
            echo -e "${RED}[警告] ${f} 中 vmproxy marker 不完整，請手動檢查${NC}"
            found=1
        fi
        # 舊版格式（相容）
        if grep -qF 'vmproxy_env' "$f" 2>/dev/null; then
            sed_i '/# vmproxy.*載入/d;/vmproxy_env/d' "$f"
            found=1
        fi
        if [[ $found -eq 1 ]]; then
            sed_i -e :a -e '/^\n*$/{$d;N;ba' -e '}' "$f"
            echo -e "${GREEN}[OK] 已從 ${f} 移除 $SCRIPT_NAME 設定${NC}"
        else
            echo -e "${YELLOW}[略過] ${f} 中未找到 $SCRIPT_NAME 設定${NC}"
        fi
    done
}

# ========================================
# F. Doctor — 診斷與維護
# ========================================

function resolve_self_path() {
    command -v "$SCRIPT_NAME" 2>/dev/null || echo "$0"
}

function run_diagnosis() {
    HOOK_MISSING=0
    INTERNET_OK=0
    UPDATE_AVAILABLE=0
    BAK_EXISTS=0
    REMOTE_VERSION=""

    load_config

    echo "---- $SCRIPT_NAME 診斷 ----"

    # 1. 設定檔
    if [[ -f "$CONFIG_FILE" ]]; then
        echo -e "  設定檔: ${CYAN}${CONFIG_FILE}${NC}     ${GREEN}✓ 存在${NC}"
    else
        echo -e "  設定檔: ${CYAN}${CONFIG_FILE}${NC}     ${YELLOW}— 未設定 (${SCRIPT_NAME} config)${NC}"
    fi

    # 2. 環境變數檔
    if [[ -f "$PROFILE_FILE" ]]; then
        echo -e "  環境變數檔: ${CYAN}${PROFILE_FILE}${NC}  ${GREEN}✓ 存在${NC}"
    else
        echo -e "  環境變數檔: ${CYAN}${PROFILE_FILE}${NC}  ${YELLOW}— 未啟用 (${SCRIPT_NAME} on 後產生)${NC}"
    fi

    # 3. Shell hook
    HOOK_OUTDATED=0
    local rc_file
    rc_file=$(detect_rc_file)
    if grep -qF '>>> vmproxy >>>' "$rc_file" 2>/dev/null; then
        echo -e "  Shell hook: ${CYAN}${rc_file}${NC}  ${GREEN}✓ 已安裝${NC}"
    elif grep -qF 'vmproxy_env' "$rc_file" 2>/dev/null; then
        echo -e "  Shell hook: ${CYAN}${rc_file}${NC}  ${YELLOW}⚠ 舊版（建議重新 init）${NC}"
        HOOK_OUTDATED=1
    else
        echo -e "  Shell hook: ${CYAN}${rc_file}${NC}  ${RED}✗ 未安裝${NC}"
        HOOK_MISSING=1
    fi

    # 4. 代理連通性
    if test_host_reachable "$PROXY_HOST" "$MIXED_PORT"; then
        echo -e "  代理連通性: ${CYAN}${PROXY_HOST}:${MIXED_PORT}${NC}  ${GREEN}✓ 可達${NC}"
    else
        echo -e "  代理連通性: ${CYAN}${PROXY_HOST}:${MIXED_PORT}${NC}  ${RED}✗ 不可達${NC}"
    fi

    # 5. 外網連通性
    if curl -fsSL --max-time 3 "$UPDATE_URL" -o /dev/null 2>/dev/null; then
        echo -e "  外網連通性: ${GREEN}✓ 可達${NC}"
        INTERNET_OK=1
    else
        echo -e "  外網連通性: ${RED}✗ 不可達${NC}"
    fi

    # 6. 版本
    local self
    self=$(resolve_self_path)
    if [[ -f "${self}.bak" ]]; then
        BAK_EXISTS=1
    fi

    if [[ $INTERNET_OK -eq 1 ]]; then
        local tmp
        tmp=$(mktemp) || return
        if curl -fsSL --max-time 5 "$UPDATE_URL" -o "$tmp" 2>/dev/null; then
            REMOTE_VERSION=$(grep '^VERSION=' "$tmp" | head -1 | cut -d'"' -f2)
            if [[ -n "$REMOTE_VERSION" && "$VERSION" != "$REMOTE_VERSION" ]]; then
                UPDATE_AVAILABLE=1
                echo -e "  版本: 本地 ${CYAN}v${VERSION}${NC} / 遠端 ${CYAN}v${REMOTE_VERSION}${NC} ${YELLOW}← 有更新${NC}"
            else
                echo -e "  版本: ${CYAN}v${VERSION}${NC} ${GREEN}✓ 最新${NC}"
            fi
        else
            echo -e "  版本: ${CYAN}v${VERSION}${NC} (無法取得遠端版本)"
        fi
        rm -f "$tmp"
    else
        echo -e "  版本: ${CYAN}v${VERSION}${NC} (外網不可達，跳過版本檢查)"
    fi

    echo ""
}

function show_doctor_menu() {
    local options=()
    local keys=()

    if [[ $UPDATE_AVAILABLE -eq 1 ]]; then
        options+=("u) 更新至 v${REMOTE_VERSION}")
        keys+=("u")
    fi
    if [[ $BAK_EXISTS -eq 1 ]]; then
        options+=("r) 回滾至上一版本")
        keys+=("r")
    fi
    if [[ $HOOK_MISSING -eq 1 ]]; then
        options+=("f) 安裝 shell hook")
        keys+=("f")
    elif [[ $HOOK_OUTDATED -eq 1 ]]; then
        options+=("f) 更新 shell hook")
        keys+=("f")
    fi

    if [[ ${#options[@]} -eq 0 ]]; then
        echo -e "${GREEN}一切正常，無需操作。${NC}"
        return
    fi

    echo "可執行操作:"
    for opt in "${options[@]}"; do
        echo "  $opt"
    done
    echo "  q) 退出"
    echo ""
    read -rp "選擇: " choice

    case "$choice" in
        u) [[ $UPDATE_AVAILABLE -eq 1 ]] && do_update || echo "無此選項" ;;
        r) [[ $BAK_EXISTS -eq 1 ]] && do_rollback || echo "無此選項" ;;
        f) [[ $HOOK_MISSING -eq 1 || $HOOK_OUTDATED -eq 1 ]] && do_fix_hook || echo "無此選項" ;;
        q|"") return ;;
        *) echo "無效的選擇" ;;
    esac
}

function do_update() {
    echo -e "${CYAN}→ 檢查更新...${NC}"

    if ! command -v curl &>/dev/null; then
        echo -e "${RED}[錯誤] 需要 curl 才能更新${NC}"
        return 1
    fi

    local tmp
    tmp=$(mktemp) || return 1
    if ! curl -fsSL "$UPDATE_URL" -o "$tmp"; then
        echo -e "${RED}[錯誤] 下載失敗${NC}"
        echo -e "  提示: 請先 ${CYAN}$SCRIPT_NAME on${NC} 啟用代理"
        rm -f "$tmp"
        return 1
    fi

    local remote_version
    remote_version=$(grep '^VERSION=' "$tmp" | head -1 | cut -d'"' -f2)
    if [[ -z "$remote_version" ]]; then
        echo -e "${RED}[錯誤] 無法取得遠端版本號${NC}"
        rm -f "$tmp"
        return 1
    fi

    echo -e "  本地版本: ${CYAN}${VERSION}${NC}"
    echo -e "  遠端版本: ${CYAN}${remote_version}${NC}"

    if [[ "$VERSION" == "$remote_version" ]]; then
        echo -e "${GREEN}[OK] 已是最新版本${NC}"
        rm -f "$tmp"
        return 0
    fi

    # 語法檢查下載的檔案
    if ! bash -n "$tmp" 2>/dev/null; then
        echo -e "${RED}[錯誤] 遠端檔案語法錯誤，放棄更新${NC}"
        rm -f "$tmp"
        return 1
    fi

    local self
    self=$(resolve_self_path)
    chmod +x "$tmp"

    # 備份當前腳本
    if cp "$self" "${self}.bak" 2>/dev/null || sudo cp "$self" "${self}.bak" 2>/dev/null; then
        echo -e "  ${GREEN}[OK] 已備份至 ${self}.bak${NC}"
    else
        echo -e "${YELLOW}[警告] 備份失敗，繼續更新${NC}"
    fi

    # 覆蓋
    if cp "$tmp" "$self" 2>/dev/null; then
        echo -e "${GREEN}[OK] 已更新至 ${remote_version}${NC}"
    else
        echo -e "${YELLOW}[提示] 需要 sudo 權限寫入 ${self}${NC}"
        if sudo cp "$tmp" "$self"; then
            echo -e "${GREEN}[OK] 已更新至 ${remote_version}${NC}"
        else
            echo -e "${RED}[錯誤] 更新失敗${NC}"
            rm -f "$tmp"
            return 1
        fi
    fi

    rm -f "$tmp"

    # 刷新 shell hook（fork 新進程讀新腳本）
    local rc_file
    rc_file=$(detect_rc_file)
    if grep -qF 'vmproxy' "$rc_file" 2>/dev/null; then
        echo ""
        "$self" init
    fi

    echo -e "  提示: 如有問題，${CYAN}$SCRIPT_NAME doctor rollback${NC}"
}

function do_rollback() {
    local self
    self=$(resolve_self_path)

    if [[ ! -f "${self}.bak" ]]; then
        echo -e "${RED}[錯誤] 找不到備份檔 ${self}.bak${NC}"
        return 1
    fi

    if cp "${self}.bak" "$self" 2>/dev/null; then
        :
    else
        echo -e "${YELLOW}[提示] 需要 sudo 權限寫入 ${self}${NC}"
        if ! sudo cp "${self}.bak" "$self"; then
            echo -e "${RED}[錯誤] 回滾失敗${NC}"
            return 1
        fi
    fi

    local rolled_version
    rolled_version=$(grep '^VERSION=' "$self" | head -1 | cut -d'"' -f2)
    echo -e "${GREEN}[OK] 已回滾至 v${rolled_version}${NC}"
}

function do_cleanup() {
    echo -e "${YELLOW}→ 清理 $SCRIPT_NAME 環境${NC}"

    # 1. 關閉系統代理
    disable_proxy

    # 2. 移除 shell hook
    uninit_shell

    # 3. 刪除設定檔
    rm -f "$CONFIG_FILE"
    echo -e "${GREEN}[OK] 已刪除 ${CONFIG_FILE}${NC}"
    rm -f "$PROFILE_FILE"
    echo -e "${GREEN}[OK] 已刪除 ${PROFILE_FILE}${NC}"

    # 4. 刪除備份檔
    local self
    self=$(resolve_self_path)
    if [[ -f "${self}.bak" ]]; then
        rm -f "${self}.bak"
        echo -e "${GREEN}[OK] 已刪除 ${self}.bak${NC}"
    fi

    echo ""
    echo -e "${GREEN}[OK] 清理完成${NC}"
    echo -e "  腳本本身請手動刪除: ${CYAN}rm ${self}${NC}"
}

function do_fix_hook() {
    init_shell
}

function doctor() {
    case "${2:-}" in
        update)    do_update ;;
        rollback)  do_rollback ;;
        cleanup)   do_cleanup ;;
        "")        run_diagnosis; show_doctor_menu ;;
        *)         echo "用法: $SCRIPT_NAME doctor [update|rollback|cleanup]" ;;
    esac
}

# ========================================
# G. 主入口
# ========================================

case "$1" in
    on)        enable_proxy ;;
    off)       disable_proxy ;;
    status)    show_status ;;
    init)      init_shell ;;
    config)    config_proxy "$@" ;;
    doctor)    doctor "$@" ;;
    *)
        echo "$SCRIPT_NAME - VM 代理管理工具 (v${VERSION})"
        echo ""
        echo "用法: $SCRIPT_NAME <指令>"
        echo ""
        echo "指令:"
        echo "  on                           啟用系統代理"
        echo "  off                          關閉系統代理"
        echo "  status                       查看代理狀態"
        echo "  init                         將自動載入寫入 shell 設定檔"
        echo "  config [host] [port]         查看/設定代理位址"
        echo "  config auto [port]           自動掃描區域網偵測代理伺服器"
        echo "  config <port>                只設定端口"
        echo "  doctor                       診斷、更新、維護"
        echo "  doctor update                更新至最新版本"
        echo "  doctor rollback              回滾至上一版本"
        echo "  doctor cleanup               清理環境（還原網路 + 移除設定）"
        echo ""
        echo "支援: macOS (networksetup), Linux (GNOME/KDE/CLI)"
        ;;
esac
